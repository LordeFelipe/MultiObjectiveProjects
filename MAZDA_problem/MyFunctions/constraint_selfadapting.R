#' "Self Adapting Penalty" constraint handling method for MOEA/D
#' 
#' Parameterless constraint component of MOEA/D that changes the penalty value
#' based on the percentage of feasible and unfeasible solutions in the current 
#' population proposed by Tessema and Yu.
#'
#' This routine implements a penalty that tries to balance the feasible and unfeasible
#' solutions to ensure diversity and convergence. If there are fewer feasible solutions,
#' the penalty will increase to the unfeasible ones and if there are more feasible soutions,
#' the penalty will decrease.
#' 
#' @param beta Static penalty parameter that will be multiplied to get the other
#' penalty coefficients
#' @param bigZ Matrix of scalarized objective values for each neighborhood and
#' the incumbent solution (generated by [scalarize_values()])
#' @param bigV Matrix of violation values for each neighborhood and the
#'
#' @return `[ N x (T+1) ]` matrix of preference indices. Each row `i` contains
#' a permutation of `{1, 2, ..., (T+1)}`, where `1,...,T` correspond
#' to the solutions contained in the neighborhood of the i-th subproblem,
#' `B[i, ]`, and `T+1` corresponds to the incumbent solution for that
#' subproblem. 

constraint_selfadapting <- function(bigZ, bigV, ...)
{
  # ========== Error catching and default value definitions
  assertthat::assert_that(
    identical(dim(bigZ), dim(bigV)))
  # ==========
  
  # Calculate the number of feasible solutions in the incubent solution
  rf = sum(parent.frame(2)$Vt$v == 0)/(length(bigV[1,]))
  
  # Get the feasible solutions of the new generation
  feasibilityMatrix = parent.frame(2)$V$v == 0
  
  #Calculate M(X)
  if(rf == 0){
    M = matrix(0,nrow = nrow(bigV), ncol = ncol(bigV))
  }
  else{
    M = bigV
  }
  
  #Calculate N(X)
  N = matrix(0,nrow = nrow(bigV), ncol = ncol(bigV))
  for(i in 1:ncol(bigZ)){
    #N is Z if the individual is feasible
    if(feasibilityMatrix[i] != 0){
      N[,i] = bigZ[,i]
    }
  }
  
  # Calculate p(X)
  P = (1-rf)*M + rf*N
  
  #Changing the value of BigZ
  if(rf == 0){
    bigZ = bigV
  }
  else{
    bigZ = sqrt(bigV^2 + bigZ^2)
  }
  
  # Calculate penalized values
  bigZV <- bigZ + P
  
  # Get the selection matrix for all neighborhoods
  sel.indx <- t(apply(bigZV,
                      MARGIN = 2,
                      FUN    = order))
  
  return(sel.indx)
}
#' "Dynamic Penalty" constraint handling method for MOEA/D
#' 
#'  Constraint component of MOEA/D that change the penalty value based on the current generation
#'  proposed by Joines and Houck
#'
#' This routine implements a CHT that increases (can decrease too) the penalty value along the generations.
#' It's main idea is to let the algorithm explore without much penalty in the first generations and
#' increase the pressure to find feasible solutions over time.
#' 
#' @param C Multiplicative parameter of the penalty
#' @param alpha Exponential paramenter of the penalty
#' @param bigZ Matrix of scalarized objective values for each neighborhood and
#' the incumbent solution (generated by [scalarize_values()])
#' @param bigV Matrix of violation values for each neighborhood and the
#'
#' @return `[ N x (T+1) ]` matrix of preference indices. Each row `i` contains
#' a permutation of `{1, 2, ..., (T+1)}`, where `1,...,T` correspond
#' to the solutions contained in the neighborhood of the i-th subproblem,
#' `B[i, ]`, and `T+1` corresponds to the incumbent solution for that
#' subproblem. 

constraint_dynamic <- function(C, alpha, bigZ, bigV, ...)
{
  # ========== Error catching and default value definitions
  assertthat::assert_that(
    identical(dim(bigZ), dim(bigV)))
  # ==========
  
  # Calculate dynamic parameter
  K <- (C*parent.frame(2)$iter)^alpha
  
  # Calculate penalized values
  bigZV <- bigZ + K * bigV
  
  # Get the selection matrix for all neighborhoods
  sel.indx <- t(apply(bigZV,
                      MARGIN = 2,
                      FUN    = order))
  
  return(sel.indx)
}